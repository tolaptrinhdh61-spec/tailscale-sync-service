name: Smart Data Sync with Tailscale (OAuth Secret Login)

on:
  workflow_dispatch:
    inputs:
      runner_id:
        description: "Runner ID (optional, auto-generated if empty)"
        required: false
        default: ""

env:
  DATA_DIR: "./.data-runner"
  SYNC_PORT: 22
  # ðŸ‘‡ Tag mÃ  OAuth client Ä‘Ã£ Ä‘Æ°á»£c cáº¥p/own (vd tag:ci). Báº¡n cÃ³ thá»ƒ set báº±ng secret TAILSCALE_TAGS.
  DEFAULT_TAILSCALE_TAGS: "tag:ci"

jobs:
  smart-runner:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate Runner ID
        id: runner-id
        run: |
          set -euo pipefail
          if [ -n "${{ github.event.inputs.runner_id }}" ]; then
            RUNNER_ID="${{ github.event.inputs.runner_id }}"
          else
            RUNNER_ID="runner-$(date +%s)-$RANDOM"
          fi
          echo "id=$RUNNER_ID" >> $GITHUB_OUTPUT
          echo "ðŸ†” Runner ID: $RUNNER_ID"

      - name: Install packages
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y jq rsync sshpass openssh-server netcat-openbsd curl

      - name: Install Tailscale
        run: |
          set -euo pipefail
          curl -fsSL https://tailscale.com/install.sh | sh

      - name: Connect to Tailscale using OAuth client secret
        id: tailscale
        env:
          TS_OAUTH_SECRET: ${{ secrets.TAILSCALE_OAUTH_CLIENT_SECRET }}
          TS_TAGS_SECRET: ${{ secrets.TAILSCALE_TAGS }}
          RUNNER_ID: ${{ steps.runner-id.outputs.id }}
        run: |
          set -euo pipefail

          TAGS="${TS_TAGS_SECRET:-${DEFAULT_TAILSCALE_TAGS}}"
          echo "ðŸ·ï¸ Using tags: $TAGS"

          # Start daemon in-memory (good for ephemeral CI runners)
          sudo tailscaled --state=mem: &

          # âœ… OAuth secret can be used directly as --auth-key
          # âœ… URL-style params supported: ephemeral, preauthorized, baseURL
          # ðŸ‘‰ We want: ephemeral=true, preauthorized=true
          sudo tailscale up \
            --auth-key="${TS_OAUTH_SECRET}?ephemeral=true&preauthorized=true" \
            --advertise-tags="${TAGS}" \
            --hostname="gh-${RUNNER_ID}" \
            --accept-dns=true \
            --accept-routes=true

          TS_IP=$(tailscale ip -4)
          TS_HOSTNAME=$(tailscale status --self | awk '{print $2}')

          echo "ip=$TS_IP" >> $GITHUB_OUTPUT
          echo "hostname=$TS_HOSTNAME" >> $GITHUB_OUTPUT

          echo "âœ… Connected"
          echo "   Hostname: $TS_HOSTNAME"
          echo "   IP      : $TS_IP"
          sudo tailscale status --peers || true

      - name: Setup SSH server (shared password)
        id: ssh-setup
        env:
          RUNNER_SSH_PASSWORD: ${{ secrets.RUNNER_SSH_PASSWORD }}
        run: |
          set -euo pipefail

          if [ -z "${RUNNER_SSH_PASSWORD:-}" ]; then
            echo "âŒ Missing secret RUNNER_SSH_PASSWORD"
            exit 1
          fi

          # Create runner user
          if ! id -u runner >/dev/null 2>&1; then
            sudo useradd -m -s /bin/bash runner
          fi

          # Set shared password for cross-runner rsync/ssh
          echo "runner:${RUNNER_SSH_PASSWORD}" | sudo chpasswd

          # Allow runner to run tailscale/shutdown without password (for remote stop)
          echo "runner ALL=(ALL) NOPASSWD: /usr/bin/tailscale, /sbin/shutdown, /bin/systemctl, /usr/sbin/service" | sudo tee /etc/sudoers.d/runner-nopasswd >/dev/null
          sudo chmod 440 /etc/sudoers.d/runner-nopasswd

          # Ensure SSH is up
          sudo systemctl enable ssh
          sudo systemctl restart ssh

          # Wait for port
          for i in $(seq 1 10); do
            if nc -z localhost 22; then
              break
            fi
            sleep 1
          done

          echo "ssh_user=runner" >> $GITHUB_OUTPUT

      # ============================================================
      # ðŸ” DISCOVER ACTIVE RUNNER (GIá»® NGUYÃŠN LOGIC Cá»¦A Báº N)
      # ============================================================
      - name: Discover Active Runners
        id: discover
        run: |
          set -euo pipefail
          echo "ðŸ” Discovering active runners in Tailscale network..."

          SELF_HOSTNAME=$(tailscale status --self | awk '{print $2}')
          echo "Self hostname: $SELF_HOSTNAME"

          # Pick first online peer whose hostname starts with gh- (excluding self)
          ACTIVE_LINE=$(sudo tailscale status --peers | awk '$0 !~ /offline/ {print $0}' | grep "gh-" | grep -v "$SELF_HOSTNAME" | head -n 1 || true)

          if [ -z "$ACTIVE_LINE" ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            echo "ðŸ“­ No active runners found in network"
            exit 0
          fi

          ACTIVE_IP=$(echo "$ACTIVE_LINE" | awk '{print $1}')
          ACTIVE_HOSTNAME=$(echo "$ACTIVE_LINE" | awk '{print $2}')

          echo "found=true" >> $GITHUB_OUTPUT
          echo "ip=$ACTIVE_IP" >> $GITHUB_OUTPUT
          echo "hostname=$ACTIVE_HOSTNAME" >> $GITHUB_OUTPUT

          echo "âœ… Found active runner:"
          echo "   Hostname: $ACTIVE_HOSTNAME"
          echo "   IP: $ACTIVE_IP"

      - name: Sync Data FROM Active Runner
        if: steps.discover.outputs.found == 'true'
        id: sync-from
        env:
          ACTIVE_IP: ${{ steps.discover.outputs.ip }}
          ACTIVE_HOSTNAME: ${{ steps.discover.outputs.hostname }}
          RUNNER_SSH_PASSWORD: ${{ secrets.RUNNER_SSH_PASSWORD }}
        run: |
          set -euo pipefail
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ðŸ“¥ SYNCING DATA FROM ACTIVE RUNNER"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "Source: $ACTIVE_HOSTNAME ($ACTIVE_IP)"
          echo "Target: ${{ steps.tailscale.outputs.hostname }} (${{ steps.tailscale.outputs.ip }})"
          echo ""

          mkdir -p "${{ env.DATA_DIR }}"

          echo "â³ Waiting for SSH on $ACTIVE_IP:${{ env.SYNC_PORT }}..."
          for i in $(seq 1 30); do
            if nc -z "$ACTIVE_IP" ${{ env.SYNC_PORT }}; then
              echo "âœ… SSH is reachable"
              break
            fi
            echo "â³ Attempt $i/30 - waiting..."
            sleep 2
          done

          echo ""
          echo "ðŸ”„ Starting rsync transfer..."
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

          RSYNC_LOG="/tmp/rsync-sync.log"
          if sshpass -p "$RUNNER_SSH_PASSWORD" rsync -avz --stats --timeout=60 \
            -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10" \
            runner@$ACTIVE_IP:${{ env.DATA_DIR }}/ \
            ${{ env.DATA_DIR }}/ 2>&1 | tee "$RSYNC_LOG"; then

            SYNCED_FILES=$(find ${{ env.DATA_DIR }} -type f | wc -l)
            SYNCED_SIZE=$(du -sh ${{ env.DATA_DIR }} 2>/dev/null | awk '{print $1}')
            SYNCED_BYTES=$(du -sb ${{ env.DATA_DIR }} 2>/dev/null | awk '{print $1}')

            echo "synced=true" >> $GITHUB_OUTPUT
            echo "files=$SYNCED_FILES" >> $GITHUB_OUTPUT
            echo "size=$SYNCED_SIZE" >> $GITHUB_OUTPUT
            echo "bytes=$SYNCED_BYTES" >> $GITHUB_OUTPUT

            echo "âœ… Sync done: $SYNCED_FILES files, $SYNCED_SIZE"
          else
            echo "âŒ Rsync failed"
            tail -n 30 "$RSYNC_LOG" || true
            echo "synced=false" >> $GITHUB_OUTPUT
          fi

      - name: Stop previous runner via SSH (no API needed)
        if: steps.discover.outputs.found == 'true' && steps.sync-from.outputs.synced == 'true'
        env:
          ACTIVE_IP: ${{ steps.discover.outputs.ip }}
          RUNNER_SSH_PASSWORD: ${{ secrets.RUNNER_SSH_PASSWORD }}
        run: |
          set -euo pipefail
          echo "ðŸ›‘ Stopping previous runner (best-effort) via SSH..."

          # Best effort: ask the old runner to disconnect from tailscale and shutdown
          sshpass -p "$RUNNER_SSH_PASSWORD" ssh \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=/dev/null \
            -o ConnectTimeout=10 \
            runner@$ACTIVE_IP \
            "sudo tailscale down || true; sudo shutdown -h now || true" || true

          echo "âœ… Stop signal sent (best-effort)"

      - name: Initialize/Update local data
        env:
          RUNNER_ID: ${{ steps.runner-id.outputs.id }}
        run: |
          set -euo pipefail
          mkdir -p "${{ env.DATA_DIR }}"
          echo "runner_id=${RUNNER_ID}" > "${{ env.DATA_DIR }}/meta.txt"
          echo "hostname=${{ steps.tailscale.outputs.hostname }}" >> "${{ env.DATA_DIR }}/meta.txt"
          echo "ip=${{ steps.tailscale.outputs.ip }}" >> "${{ env.DATA_DIR }}/meta.txt"
          echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> "${{ env.DATA_DIR }}/meta.txt"
          echo "run_id=${{ github.run_id }}" >> "${{ env.DATA_DIR }}/meta.txt"
          echo "run_number=${{ github.run_number }}" >> "${{ env.DATA_DIR }}/meta.txt"

      - name: Keep runner alive for next sync
        run: |
          set -euo pipefail
          echo "ðŸ“¡ Runner is ready for next job to sync from it."
          echo "   Hostname: ${{ steps.tailscale.outputs.hostname }}"
          echo "   IP      : ${{ steps.tailscale.outputs.ip }}"
          echo "   SSH     : runner@${{ steps.tailscale.outputs.ip }}:${{ env.SYNC_PORT }}"
          echo ""
          # Keep alive a bit (tweak as needed)
          for i in $(seq 1 30); do
            sleep 10
            sudo tailscale status --peers | head -n 20 || true
          done

      - name: Cleanup Tailscale
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up Tailscale connection..."
          sudo tailscale down || true
          echo "âœ… Cleanup completed"
