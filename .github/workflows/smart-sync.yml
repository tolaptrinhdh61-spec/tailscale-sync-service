name: Smart Data Sync with Tailscale

on:
  workflow_dispatch:
    inputs:
      runner_id:
        description: "Runner ID (optional, auto-generated if empty)"
        required: false
        default: ""

env:
  DATA_DIR: "./.data-runner"
  SYNC_PORT: 22

jobs:
  smart-runner:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Generate Runner ID
        id: runner-id
        run: |
          if [ -n "${{ github.event.inputs.runner_id }}" ]; then
            RUNNER_ID="${{ github.event.inputs.runner_id }}"
          else
            RUNNER_ID="runner-$(date +%s)-$RANDOM"
          fi
          echo "id=$RUNNER_ID" >> $GITHUB_OUTPUT
          echo "üÜî Runner ID: $RUNNER_ID"

      - name: Get Tailscale OAuth Token
        id: ts-oauth
        env:
          TS_CLIENT_ID: ${{ secrets.TAILSCALE_CLIENT_ID }}
          TS_CLIENT_SECRET: ${{ secrets.TAILSCALE_CLIENT_SECRET }}
          # Scope & tags are REQUESTED here, but they must also be GRANTED on the OAuth client in Tailscale admin.
          # For this workflow we need at least: devices:core (list/delete devices) + auth_keys (create auth keys).
          TS_OAUTH_SCOPE: "devices:core auth_keys"
          # Tags matter only when scopes include devices:core, auth_keys, or all.
          TS_OAUTH_TAGS: "tag:ci"
        run: |
          set -euo pipefail
          echo "üîê Getting OAuth access token (request scope: $TS_OAUTH_SCOPE; tags: $TS_OAUTH_TAGS)..."

          RESPONSE=$(curl -sS -w "\nHTTP_CODE:%{http_code}" \
            -d "grant_type=client_credentials" \
            -d "client_id=${TS_CLIENT_ID}" \
            -d "client_secret=${TS_CLIENT_SECRET}" \
            --data-urlencode "scope=all" \
            "https://api.tailscale.com/api/v2/oauth/token")

          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          BODY=$(echo "$RESPONSE" | grep -v "HTTP_CODE:")

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "200" ]; then
            echo "‚ùå Failed to get OAuth token (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
            exit 1
          fi

          ACCESS_TOKEN=$(echo "$BODY" | jq -r '.access_token')
          TOKEN_SCOPE=$(echo "$BODY" | jq -r '.scope // ""')

          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
            echo "‚ùå Invalid access token received"
            echo "Response: $BODY"
            exit 1
          fi

          echo "‚úÖ OAuth token acquired"
          echo "‚ÑπÔ∏è  Granted scope: $TOKEN_SCOPE"

          # Hard gate: this workflow needs create auth keys + device management.
          if [[ "$TOKEN_SCOPE" != *"auth_keys"* ]] || [[ "$TOKEN_SCOPE" != *"devices:core"* && "$TOKEN_SCOPE" != *"all"* ]]; then
            echo ""
            echo "‚ùå OAuth client doesn't have enough permissions for this workflow."
            echo "   Required: auth_keys + devices:core (or all)"
            echo "   Granted : $TOKEN_SCOPE"
            echo ""
            echo "üëâ Fix:"
            echo "   - In Tailscale Admin Console ‚Üí Trust credentials ‚Üí OAuth:"
            echo "     enable WRITE for Auth keys and Devices (devices:core), and allow tag:ci (or your tag)."
            echo "   - Owners/Admins can grant any scopes/tags; other roles may be limited."
            exit 1
          fi

          echo "token=$ACCESS_TOKEN" >> $GITHUB_OUTPUT
          echo "scope=$TOKEN_SCOPE" >> $GITHUB_OUTPUT
          echo "tags=$TS_OAUTH_TAGS" >> $GITHUB_OUTPUT

      - name: Create Tailscale Auth Key
        id: ts-authkey
        env:
          ACCESS_TOKEN: ${{ steps.ts-oauth.outputs.token }}
        run: |
          echo "üîë Creating reusable and ephemeral auth key..."

          # Create auth key with API (using '-' as tailnet - auto-detect from token)
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            -d '{
              "capabilities": {
                "devices": {
                  "create": {
                    "reusable": true,
                    "ephemeral": true,
                    "preauthorized": true,
                    "tags": ["tag:ci"]
                  }
                }
              },
              "expirySeconds": 7776000,
              "description": "gha-smart-sync auth key"
            }' \
            "https://api.tailscale.com/api/v2/tailnet/-/keys")

          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          BODY=$(echo "$RESPONSE" | grep -v "HTTP_CODE:")

          echo "HTTP Status Code: $HTTP_CODE"

          if [ "$HTTP_CODE" != "200" ] && [ "$HTTP_CODE" != "201" ]; then
            echo "‚ùå Failed to create auth key (HTTP $HTTP_CODE)"
            echo "Response: $BODY"
            exit 1
          fi

          AUTH_KEY=$(echo "$BODY" | jq -r '.key')

          if [ -z "$AUTH_KEY" ] || [ "$AUTH_KEY" = "null" ]; then
            echo "‚ùå Invalid auth key received"
            echo "Response: $BODY"
            exit 1
          fi

          echo "authkey=$AUTH_KEY" >> $GITHUB_OUTPUT
          echo "‚úÖ Auth key created (reusable, ephemeral, 90 days expiry)"

      - name: Setup Tailscale
        env:
          AUTH_KEY: ${{ steps.ts-authkey.outputs.authkey }}
          RUNNER_ID: ${{ steps.runner-id.outputs.id }}
        run: |
          set -euo pipefail
          echo "üì¶ Installing Tailscale..."
          curl -fsSL https://tailscale.com/install.sh | sh
          sudo tailscaled --state=mem: &

          echo "üîê Connecting to Tailscale network..."
          sudo tailscale up --auth-key="${AUTH_KEY}" --hostname="gh-${RUNNER_ID}" --accept-routes --accept-dns

          echo "‚úÖ Connected. My Tailscale IPv4: $(tailscale ip -4)"
          sudo tailscale status --peers || true

      - name: Setup SSH Server
        id: ssh-setup
        run: |
          set -euo pipefail
          echo "üîß Configuring SSH server..."

          sudo apt-get update -y
          sudo apt-get install -y openssh-server rsync sshpass jq

          sudo systemctl enable ssh
          sudo systemctl start ssh

          # Create a dedicated user for sync
          if ! id -u runner >/dev/null 2>&1; then
            sudo useradd -m -s /bin/bash runner
          fi

          SSH_PASS="pw-$(date +%s)-$RANDOM"
          echo "SSH password generated"

          echo "runner:${SSH_PASS}" | sudo chpasswd

          sudo mkdir -p /home/runner/.ssh
          sudo chmod 700 /home/runner/.ssh
          sudo chown -R runner:runner /home/runner/.ssh

          # Wait ssh
          for i in $(seq 1 10); do
            if nc -z localhost 22; then
              break
            fi
            sleep 1
          done

          echo "ssh_pass=$SSH_PASS" >> $GITHUB_OUTPUT

      # ============================================================
      # üîç DISCOVER ACTIVE RUNNER (GI·ªÆ NGUY√äN LOGIC C·ª¶A B·∫†N)
      # ============================================================
      - name: Discover Active Runners
        id: discover
        env:
          ACCESS_TOKEN: ${{ steps.ts-oauth.outputs.token }}
        run: |
          echo "üîç Discovering active runners in Tailscale network..."

          # Get list of all online peers (excluding self)
          SELF_HOSTNAME=$(tailscale status --self | awk '{print $2}')
          echo "Self hostname: $SELF_HOSTNAME"

          # Find active runners starting with 'gh-' (exclude self and offline nodes)
          ACTIVE_RUNNERS=$(sudo tailscale status --peers | awk '$0 !~ /offline/ {print $1" "$2}' | grep "gh-" | grep -v "$SELF_HOSTNAME" | awk '{print $1}' || echo "")

          if [ -z "$ACTIVE_RUNNERS" ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            echo "üì≠ No active runners found in network"
          else
            # Get first active runner
            ACTIVE_IP=$(echo "$ACTIVE_RUNNERS" | head -1)
            ACTIVE_HOSTNAME=$(sudo tailscale status | grep "$ACTIVE_IP" | awk '{print $2}')

            echo "found=true" >> $GITHUB_OUTPUT
            echo "ip=$ACTIVE_IP" >> $GITHUB_OUTPUT
            echo "hostname=$ACTIVE_HOSTNAME" >> $GITHUB_OUTPUT

            echo "‚úÖ Found active runner:"
            echo "   Hostname: $ACTIVE_HOSTNAME"
            echo "   IP: $ACTIVE_IP"

            # Extract runner ID from hostname (gh-XXXXX)
            REMOTE_RUNNER_ID=$(echo "$ACTIVE_HOSTNAME" | sed 's/gh-//')
            echo "remote_runner_id=$REMOTE_RUNNER_ID" >> $GITHUB_OUTPUT
          fi

      - name: Sync Data FROM Active Runner
        if: steps.discover.outputs.found == 'true'
        id: sync-from
        env:
          ACTIVE_IP: ${{ steps.discover.outputs.ip }}
          ACTIVE_HOSTNAME: ${{ steps.discover.outputs.hostname }}
          REMOTE_RUNNER_ID: ${{ steps.discover.outputs.remote_runner_id }}
          RUNNER_ID: ${{ steps.runner-id.outputs.id }}
          REMOTE_PASS: ${{ steps.ssh-setup.outputs.ssh_pass }}
        run: |
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "üì• SYNCING DATA FROM ACTIVE RUNNER"
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
          echo "Source: $ACTIVE_HOSTNAME ($ACTIVE_IP)"
          echo "Target: gh-$RUNNER_ID ($(tailscale ip -4))"
          echo ""

          mkdir -p ${{ env.DATA_DIR }}

          echo "‚è≥ Waiting for SSH on $ACTIVE_IP:${{ env.SYNC_PORT }}..."
          for i in $(seq 1 30); do
            if nc -z "$ACTIVE_IP" ${{ env.SYNC_PORT }}; then
              echo "‚úÖ SSH is reachable"
              break
            fi
            echo "‚è≥ Attempt $i/30 - waiting..."
            sleep 2
          done

          echo ""
          echo "üîÑ Starting rsync transfer..."
          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

          RSYNC_LOG="/tmp/rsync-sync.log"
          RSYNC_STATS="/tmp/rsync-stats.txt"

          if sshpass -p "$REMOTE_PASS" rsync -avz --stats --timeout=60 \
            -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o ConnectTimeout=10" \
            runner@$ACTIVE_IP:${{ env.DATA_DIR }}/ \
            ${{ env.DATA_DIR }}/ 2>&1 | tee "$RSYNC_LOG"; then

            echo ""
            echo "‚úÖ Rsync completed successfully"

            grep -A 20 "Number of files" "$RSYNC_LOG" > "$RSYNC_STATS" || true

            SYNCED_FILES=$(find ${{ env.DATA_DIR }} -type f | wc -l)
            SYNCED_SIZE=$(du -sh ${{ env.DATA_DIR }} 2>/dev/null | awk '{print $1}')
            SYNCED_BYTES=$(du -sb ${{ env.DATA_DIR }} 2>/dev/null | awk '{print $1}')

            echo ""
            echo "üìä Sync Statistics:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            echo "   Total files synced: $SYNCED_FILES"
            echo "   Total size        : $SYNCED_SIZE"
            echo "   Total bytes       : $SYNCED_BYTES"

            echo "synced=true" >> $GITHUB_OUTPUT
            echo "files=$SYNCED_FILES" >> $GITHUB_OUTPUT
            echo "size=$SYNCED_SIZE" >> $GITHUB_OUTPUT
            echo "bytes=$SYNCED_BYTES" >> $GITHUB_OUTPUT

            echo ""
            echo "üìã Synced files list:"
            echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
            ls -lah ${{ env.DATA_DIR }}/ | tail -n +4 | head -20
            if [ "$SYNCED_FILES" -gt 20 ]; then
              echo "   ... and $((SYNCED_FILES - 20)) more files"
            fi

          else
            echo ""
            echo "‚ùå Rsync failed"
            cat "$RSYNC_LOG" | tail -20
            echo "synced=false" >> $GITHUB_OUTPUT
          fi

          echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

      - name: Remove Active Runner from Network
        if: steps.discover.outputs.found == 'true' && steps.sync-from.outputs.synced == 'true'
        env:
          ACCESS_TOKEN: ${{ steps.ts-oauth.outputs.token }}
          ACTIVE_HOSTNAME: ${{ steps.discover.outputs.hostname }}
        run: |
          set -euo pipefail
          echo "üî¥ Removing active runner from Tailscale network..."

          DEVICES=$(curl -s -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            "https://api.tailscale.com/api/v2/tailnet/-/devices")

          DEVICE_ID=$(echo "$DEVICES" | jq -r --arg hn "$ACTIVE_HOSTNAME" '.devices[] | select(.hostname==$hn) | .id' | head -n 1)

          if [ -z "$DEVICE_ID" ] || [ "$DEVICE_ID" = "null" ]; then
            echo "‚ö†Ô∏è Could not find device id for $ACTIVE_HOSTNAME; skipping delete."
            exit 0
          fi

          DELETE_RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" -X DELETE \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            "https://api.tailscale.com/api/v2/device/${DEVICE_ID}")

          HTTP_CODE=$(echo "$DELETE_RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)

          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
            echo "‚úÖ Successfully removed $ACTIVE_HOSTNAME from network"
            echo "   Device will be automatically cleaned up (ephemeral mode)"
          else
            echo "‚ö†Ô∏è Failed to remove device (HTTP $HTTP_CODE)"
            echo "Response: $(echo "$DELETE_RESPONSE" | grep -v "HTTP_CODE:")"
          fi

      - name: Initialize/Update local data (no active runner found)
        if: steps.discover.outputs.found != 'true'
        run: |
          echo "üìù Initializing/Updating local data..."
          mkdir -p ${{ env.DATA_DIR }}
          echo "created_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)" > ${{ env.DATA_DIR }}/meta.txt

      - name: Your actual job steps
        run: |
          echo "‚úÖ Place your build/sync tasks here"
          # e.g. write something into $DATA_DIR so it persists
          echo "last_run=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> ${{ env.DATA_DIR }}/meta.txt

      - name: Keep SSH available for next runner
        env:
          RUNNER_ID: ${{ steps.runner-id.outputs.id }}
        run: |
          echo "üì° Runner is now ready to serve data to the next runner."
          echo "   Hostname: gh-${RUNNER_ID}"
          echo "   IP      : $(tailscale ip -4)"
          echo "Monitoring connections..."
          # Keep alive a bit so peer can rsync in (tweak as needed)
          for i in $(seq 1 30); do
            sleep 10
            echo "‚è±Ô∏è  [$((i/6)):$(( (i%6)*10 ))] Status check..."
            sudo tailscale status --peers | head -n 20 || true
          done

      - name: Cleanup Tailscale
        if: always()
        run: |
          echo "üßπ Cleaning up Tailscale connection..."
          sudo tailscale down || true
          echo "‚úÖ Cleanup completed - ephemeral device will auto-remove"
